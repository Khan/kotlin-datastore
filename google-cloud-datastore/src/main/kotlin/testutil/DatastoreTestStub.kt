/**
 * Utilities for stubbing out the datastore in library clients' tests.
 *
 * We provide a lightweight test stub that can do basic operations on a list of
 * entities that you provide as the fake datastore contents. This is very
 * lightweight, and suitable for tests that touch code that needs to do some
 * simple datastore operations, but we don't simulate all behavior of the
 * datastore, like eventual consistency, transaction collisions, etc.
 *
 * TODO(colin): the Google client library suggests using the datastore emulator
 * for testing. We should support that as an alternate heavier-weight but more
 * accurate implementation for the test stub.
 *
 * To use:
 * - include org.khanacademy.datastore.testutil.DatastoreTestStub using the
 *   service loader pattern. This will cause all datastore access to throw by
 *   default.
 * - Provide mock datastore behavior within whatever scope is appropriate for
 *   your tests using `withMockDatastore`, which takes a variable number of
 *   either Keyed<*> or Entity, representing the entities that should be in the
 *   mock datastore.
 *
 * Example usage (Entity-based interface):
 *
 * val myKey: Key<TestModel> = ...
 * val myEntity = Entity.newBuilder(myKey.toDatastoreKey())
 *     .setString("aString", "a_string_value")
 *     .build()
 *
 * withMockDatastore(myEntity) {
 *     DB.get(myKey).aString shouldBe "a_string_value"
 * }
 */
package org.khanacademy.datastore.testutil

import com.google.cloud.datastore.Batch
import com.google.cloud.datastore.Cursor
import com.google.cloud.datastore.Datastore
import com.google.cloud.datastore.DatastoreOptions
import com.google.cloud.datastore.DatastoreTypeConverter
import com.google.cloud.datastore.Entity
import com.google.cloud.datastore.FullEntity
import com.google.cloud.datastore.IncompleteKey
import com.google.cloud.datastore.Key
import com.google.cloud.datastore.KeyFactory
import com.google.cloud.datastore.Query
import com.google.cloud.datastore.QueryResults
import com.google.cloud.datastore.ReadOption
import com.google.cloud.datastore.StructuredQuery
import com.google.cloud.datastore.Transaction
import com.google.datastore.v1.Key.PathElement.IdTypeCase
import com.google.datastore.v1.PropertyFilter
import com.google.datastore.v1.TransactionOptions
import com.google.datastore.v1.Value
import com.google.protobuf.NullValue
import com.google.protobuf.Timestamp
import org.khanacademy.datastore.DatastoreBackend
import org.khanacademy.datastore.DatastoreEnv
import org.khanacademy.datastore.DatastoreEnvWithProject
import org.khanacademy.datastore.DatastoreKey
import org.khanacademy.datastore.restoreLocalDBAfter
import org.khanacademy.datastore.toDatastoreEntity
import org.khanacademy.metadata.Keyed

typealias KeyPb = com.google.datastore.v1.Key

/**
 * An implementation of Google's `Datastore` that throws on all methods.
 *
 * We use this as the default to make sure that tests always have to choose
 * their behavior explicitly.
 *
 * TODO(colin): I autogenerated these stubs from a java interface, and it's not
 * clear that the nullability is right in all cases. Audit this as we fill in
 * the mocked datastore implementation.
 */
open class ThrowingDatastore : Datastore {
    override fun <T : Any?> run(
        query: Query<T>?, vararg options: ReadOption?
    ): QueryResults<T> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> run(query: Query<T>?): QueryResults<T> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun put(entity: FullEntity<*>?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun put(vararg entities: FullEntity<*>?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newKeyFactory(): KeyFactory {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun allocateId(key: IncompleteKey?): Key {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun allocateId(vararg keys: IncompleteKey?): MutableList<Key> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun update(vararg entities: Entity?) {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun add(entity: FullEntity<*>?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun add(vararg entities: FullEntity<*>?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun fetch(
        keys: MutableIterable<Key>?, vararg options: ReadOption?
    ): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun fetch(vararg keys: Key?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> runInTransaction(
        callable: Datastore.TransactionCallable<T>?
    ): T {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> runInTransaction(
        callable: Datastore.TransactionCallable<T>?,
        options: TransactionOptions?
    ): T {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newBatch(): Batch {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newTransaction(options: TransactionOptions?): Transaction {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newTransaction(): Transaction {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(key: Key?, vararg options: ReadOption?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(
        keys: MutableIterable<Key>?, vararg options: ReadOption?
    ): MutableIterator<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(key: Key?): Entity? {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(vararg keys: Key?): MutableIterator<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun getOptions(): DatastoreOptions {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun delete(vararg keys: Key?) {
        throw NotImplementedError("You must mock the datastore in tests.")
    }
}

class DatastoreTestStub : DatastoreBackend {
    override val envs: List<DatastoreEnv> = listOf(DatastoreEnv.TEST)

    override fun getDatastore(
        envAndProject: DatastoreEnvWithProject
    ): Datastore = ThrowingDatastore()
}

/**
 * Implementation of java.lang.Comparable for Timestamps.
 */
internal fun Timestamp.compareTo(other: Timestamp): Int {
    val resultToSeconds = this.seconds.compareTo(other.seconds)
    return if (resultToSeconds == 0) {
        this.nanos.compareTo(other.nanos)
    } else {
        resultToSeconds
    }
}

/**
 * If a list is shorter than a specified size, pad it with nulls to that size.
 */
internal fun <T> maybeNullPad(list: List<T>, toLength: Int): List<T?> =
    if (list.size >= toLength) {
        list
    } else {
        list + List(toLength - list.size) { null }
    }

/**
 * Implementation of java.lang.Comparable for Key protobufs.
 *
 * For keys of the same number of path elements and the same type, this
 * compares as would (kind, id, kind, id, ...) tuples.
 *
 * If we're comparing a key to another key that's longer but shares the same
 * prefix, the shorter key is ordered first.
 *
 * If we're comparing keys of mixed name / id types, an integer ID always
 * compares lower than a string name.
 *
 * These edge-case comparison rules are based on the key comparison code in
 * the python datastore API:
 * https://github.com/Khan/frankenserver/blob/master/python/google/appengine/api/datastore_types.py
 *
 * TODO(colin): if we relax the single-project constraint, then we should
 * compare projectId (called app in python) here too.
 */
internal fun KeyPb.compareTo(other: KeyPb): Int {
    if (partitionId.namespaceId != other.partitionId.namespaceId) {
        return partitionId.namespaceId.compareTo(other.partitionId.namespaceId)
    }

    val elementPairs = maybeNullPad(pathList, other.pathList.size)
        .zip(maybeNullPad(other.pathList, pathList.size))

    return elementPairs.fold(0) { result, (left, right) ->
        when {
            // If an earlier element compared non-equal, we use that result.
            result != 0 -> result

            // null compares less than everything
            left == null && right != null -> -1
            left != null && right == null -> 1
            left == null && right == null -> 0

            // Compare kinds first according to normal string rules.
            // We're using null assertions here because the compiler can't
            // infer the above three boolean conditions were an exhaustive null
            // check.
            left!!.kind != right!!.kind ->
                left.kind.compareTo(right.kind)

            // IDs always compare less than names.
            left.idTypeCase == IdTypeCase.ID &&
                right.idTypeCase == IdTypeCase.NAME -> -1
            left.idTypeCase == IdTypeCase.NAME &&
                right.idTypeCase == IdTypeCase.ID -> 1

            // If we have the same ID/name type for both, use normal comparison
            // rules.
            left.idTypeCase == IdTypeCase.ID ->
                left.id.compareTo(right.id)
            left.idTypeCase == IdTypeCase.NAME ->
                left.name.compareTo(right.name)
            else ->
                throw Exception(
                    "This should be unreachable code and reflects a bug in " +
                        "the library. Debug: left = $left, right = $right.")
        }
    }
}

// Used to order values of different types, as per
// https://cloud.google.com/datastore/docs/concepts/entities#value_type_ordering
private fun Value.typeIndex(): Int =
    when (valueTypeCase) {
        Value.ValueTypeCase.NULL_VALUE -> 1
        Value.ValueTypeCase.INTEGER_VALUE,
        Value.ValueTypeCase.TIMESTAMP_VALUE -> 2
        Value.ValueTypeCase.BOOLEAN_VALUE -> 3
        // The docs say "byte strings" sort before "unicode strings".
        // I'm taking the first to mean "blob" and the second "string".
        Value.ValueTypeCase.BLOB_VALUE -> 4
        Value.ValueTypeCase.STRING_VALUE -> 5
        Value.ValueTypeCase.DOUBLE_VALUE -> 6
        Value.ValueTypeCase.GEO_POINT_VALUE -> 7
        Value.ValueTypeCase.KEY_VALUE -> 8
        Value.ValueTypeCase.ENTITY_VALUE,
        Value.ValueTypeCase.ARRAY_VALUE ->
            throw IllegalArgumentException(
                "Callers should be comparing list/entity values explicitly.")
        Value.ValueTypeCase.VALUETYPE_NOT_SET, null ->
            throw IllegalArgumentException(
                "Cannot query on values of unknown type.")
    }

/**
 * Implementation of java.lang.Comparable for Values, used in query conditions.
 *
 * We assume that both values are of the same type.
 */
internal operator fun Value.compareTo(other: Value): Int {
    // First, handle the case the values are of different types.
    val indexCmp = typeIndex().compareTo(other.typeIndex())
    if (indexCmp != 0) {
        return indexCmp
    }
    return when(valueTypeCase) {
        // Now, handle the (common) case the values are of the same type.
        Value.ValueTypeCase.NULL_VALUE -> 0
        Value.ValueTypeCase.BOOLEAN_VALUE ->
            this.booleanValue.compareTo(other.booleanValue)
        Value.ValueTypeCase.INTEGER_VALUE ->
            this.integerValue.compareTo(other.integerValue)
        Value.ValueTypeCase.DOUBLE_VALUE ->
            this.doubleValue.compareTo(other.doubleValue)
        Value.ValueTypeCase.TIMESTAMP_VALUE ->
            this.timestampValue.compareTo(other.timestampValue)
        Value.ValueTypeCase.KEY_VALUE ->
            this.keyValue.compareTo(other.keyValue)
        Value.ValueTypeCase.STRING_VALUE ->
            this.stringValue.compareTo(other.stringValue)
        Value.ValueTypeCase.BLOB_VALUE ->
            throw IllegalArgumentException("Cannot query on blob values.")
        Value.ValueTypeCase.GEO_POINT_VALUE ->
            TODO("Implement geo point properties")
        Value.ValueTypeCase.ENTITY_VALUE ->
            TODO("Implement entity properties")
        Value.ValueTypeCase.ARRAY_VALUE ->
            TODO("Implement repeated properties")
        Value.ValueTypeCase.VALUETYPE_NOT_SET, null ->
            throw IllegalArgumentException(
                "Cannot query on values of unknown type (value ${this}).")
        else ->
            throw IllegalArgumentException(
                "Unhandled value type case ${valueTypeCase}.")
    }
}

/**
 * Does the provided entity match the given filter?
 *
 * We treat missing values on the entity as `null`.
 */
internal fun entityMatches(
    entityValue: Value,
    filter: PropertyFilter
): Boolean {
    val filterValue = filter.value

    // matchesFilters(), the caller of entityMatches(), should have
    // already filtered out the array case.
    assert(entityValue.valueTypeCase != Value.ValueTypeCase.ARRAY_VALUE)

    // TODO(colin): should we complain if
    //    filter.value.valueTypeCase != entityValue.valueTypeCase
    // and neither is null?  This is probably a programming error.

    return when (filter.op) {
        PropertyFilter.Operator.EQUAL ->
            // Note that we're not using the == operator because the ordering
            // we're using here is not guaranteed to match the behavior of
            // equals. (In particular some types may use object identity, which
            // we don't want.)
            entityValue.compareTo(filterValue) == 0
        PropertyFilter.Operator.GREATER_THAN ->
            entityValue > filterValue
        PropertyFilter.Operator.GREATER_THAN_OR_EQUAL ->
            entityValue >= filterValue
        PropertyFilter.Operator.LESS_THAN ->
            entityValue < filterValue
        PropertyFilter.Operator.LESS_THAN_OR_EQUAL ->
            entityValue <= filterValue
        PropertyFilter.Operator.HAS_ANCESTOR ->
            TODO("Implement ancestor queries.")
        PropertyFilter.Operator.OPERATOR_UNSPECIFIED,
        PropertyFilter.Operator.UNRECOGNIZED,
        null ->
            throw IllegalArgumentException(
                "Cannot run a query with unspecified operator.")
    }
}

private fun PropertyFilter.isInequalityFilter(): Boolean {
    return when (op) {
        PropertyFilter.Operator.GREATER_THAN,
        PropertyFilter.Operator.GREATER_THAN_OR_EQUAL,
        PropertyFilter.Operator.LESS_THAN,
        PropertyFilter.Operator.LESS_THAN_OR_EQUAL -> true
        else -> false
    }
}

/**
 * Datastore implementation that uses a list of entities as its fake contents.
 *
 * TODO(colin): this doesn't support the full set of datastore operations yet.
 * Fill this in as more functionality is implemented. For now this will throw
 * on any unimplemented operations.
 *
 * TODO(colin): we'll want to do some synchronization around updating the
 * internal state.
 */
class MockDatastore(private var entities: List<Entity>) : ThrowingDatastore() {
    override fun get(key: Key?): Entity? =
        entities.firstOrNull { it.key == key }

    override fun put(entity: FullEntity<*>?): Entity {
        val entityConverted = entity as Entity
        entities += entityConverted
        return entityConverted
    }

    // Checks that we match all filters that have the same name and
    // is-inequality status.  For instance, filters might be
    // `(myint > 4, myint < 6)` -- but would never be
    // `(myint > 4, myint = 5)`.
    private fun matchesFiltersForField(
        entity: Entity,
        filters: List<PropertyFilter>
    ): Boolean {
        val filterName = filters[0].property.name
        val entityValue = DatastoreTypeConverter.entityToPb(entity)
            .propertiesMap[filterName]
            ?: Value.newBuilder().setNullValue(NullValue.NULL_VALUE).build()

        // If we have an array-value and inequality filters, we have
        // to use this rule: the entity passes if there is some value
        // in the array which passes all the inequalities.  For
        // instance if we have '(myint > 4, myint < 6)', and our array
        // values are [3, 10], we do *not* pass because neither array
        // value passes both inequalities.
        // Note if filters[0] is an inequality filter, they all are,
        // because of how we grouped the filters.
        return when {
            entityValue.valueTypeCase == Value.ValueTypeCase.ARRAY_VALUE &&
            filters[0].isInequalityFilter() ->
                entityValue.arrayValue.valuesList.any { value ->
                    filters.all { filter -> entityMatches(value, filter) }
                }

            entityValue.valueTypeCase == Value.ValueTypeCase.ARRAY_VALUE ->
                // This is equality for arrays, we do the "normal"
                // thing where we match filter-by-filter: each equality
                // filter passes if the filter-string is present in our array.
                filters.all { filter ->
                    entityValue.arrayValue.valuesList.any { value ->
                        entityMatches(value, filter)
                    }
                }

            else ->
                // Non-array case, very straightforward.
                filters.all { filter -> entityMatches(entityValue, filter) }
        }
    }

    private fun runEntities(query: Query<*>?): List<Entity> {
        val structuredQuery = query as? StructuredQuery<*>
            ?: throw NotImplementedError(
                "Only structured queries are implemented in the test stub.")
        val filter = DatastoreTypeConverter.filterToPb(structuredQuery.filter)
        // TODO(colin): this only handles a top-level composite filter, which
        // is all our query code will currently generate. But probably better
        // to enforce this somehow?
        val allFilters = if (filter.hasCompositeFilter()) {
            filter.compositeFilter.filtersList.map { it.propertyFilter }
        } else {
            listOf(filter.propertyFilter)
        }

        // Most of the time, an entity passes a list of filters if it
        // passes each filter individually.  However, there is a
        // special case, as documented at
        // https://cloud.google.com/datastore/docs/concepts/queries#array_values
        // This case is inequality filters on array values.  For those
        // filters, we need to consider the filters *as a group*, not
        // just one at a time.  To help with that, we group filters
        // by <name, is_inequality_filter>.
        val filtersByNameAndType = allFilters.groupBy {
            Pair(it.property.name, it.isInequalityFilter())
        }

        return entities
            .filter { entity -> entity.key.kind == query.kind }
            .filter { entity ->
                // We consider each filter-group in sequence, the
                // entity has to pass them all.
                filtersByNameAndType.all { entry ->
                    matchesFiltersForField(entity, entry.value)
                }
            }
    }

    private fun runKeys(query: Query<*>?): List<DatastoreKey> =
        runEntities(query).map { it.key }

    @Suppress("UNCHECKED_CAST")
    override fun <T> run(query: Query<T>?): QueryResults<T> {
        val resultType = DatastoreTypeConverter.queryResultType(query)
        return when (resultType) {
            Query.ResultType.ENTITY ->
                MockQueryResults(runEntities(query))
            Query.ResultType.KEY ->
                MockQueryResults(runKeys(query))
            else ->
                throw NotImplementedError(
                    "Only entity and key queries are supported.")
        } as QueryResults<T>
    }

    companion object {
        class MockQueryResults<T>(
            private val results: List<T>
        ) : QueryResults<T>, Iterator<T> by results.iterator() {
            override fun getSkippedResults(): Int {
                throw NotImplementedError("Not implemented in the test stub.")
            }

            override fun getCursorAfter(): Cursor {
                throw NotImplementedError("Not implemented in the test stub.")
            }

            override fun remove() {
                throw NotImplementedError("Not implemented in the test stub.")
            }

            override fun getResultClass(): Class<*> {
                throw NotImplementedError("Not implemented in the test stub.")
            }
        }
    }
}

/**
 * Within a block of code, mock the datastore to contain the provided objects.
 */
fun <T> withMockDatastore(
    vararg entities: Keyed<*>, block: () -> T
): T {
    val converted = entities.map { it.toDatastoreEntity() }.toTypedArray()
    return withMockDatastore(*converted, block = block)
}

/**
 * Within a block of code, mock the datastore to contain the provided objects.
 */
fun <T> withMockDatastore(
    entities: Collection<Keyed<*>>, block: () -> T
) = withMockDatastore(*entities.toTypedArray(), block = block)

/**
 * Within a block of code, mock the datastore to contain the provided entities.
 *
 * Note that this is intended primarily for testing in contexts where
 * third-party APIs use `Entity`s. Prefer to use the version with Keyed<*>
 * instead where possible.
 */
fun <T> withMockDatastore(
    vararg entities: Entity, block: () -> T
): T = restoreLocalDBAfter {
    // NOTE: this constructor will set the value of `localDB`
    org.khanacademy.datastore.Datastore(MockDatastore(entities.toList()))
    block()
}
