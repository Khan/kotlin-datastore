/**
 * Utilities for stubbing out the datastore in library clients' tests.
 *
 * We provide a lightweight test stub that can do basic operations on a list of
 * entities that you provide as the fake datastore contents. This is very
 * lightweight, and suitable for tests that touch code that needs to do some
 * simple datastore operations, but we don't simulate all behavior of the
 * datastore, like eventual consistency, transaction collisions, etc.
 *
 * TODO(colin): the Google client library suggests using the datastore emulator
 * for testing. We should support that as an alternate heavier-weight but more
 * accurate implementation for the test stub.
 *
 * To use:
 * - include org.khanacademy.datastore.testutil.DatastoreTestStub using the
 *   service loader pattern. This will cause all datastore access to throw by
 *   default.
 * - Provide mock datastore behavior within whatever scope is appropriate for
 *   your tests using `withMockDatastore`, which takes a variable number of
 *   either Keyed<*> or Entity, representing the entities that should be in the
 *   mock datastore.
 *
 * Example usage (Entity-based interface):
 *
 * val myKey: Key<TestModel> = ...
 * val myEntity = Entity.newBuilder(myKey.toDatastoreKey())
 *     .setString("aString", "a_string_value")
 *     .build()
 *
 * withMockDatastore(myEntity) {
 *     DB.get(myKey).aString shouldBe "a_string_value"
 * }
 */
package org.khanacademy.datastore.testutil

import com.google.cloud.datastore.Batch
import com.google.cloud.datastore.Cursor
import com.google.cloud.datastore.Datastore
import com.google.cloud.datastore.DatastoreOptions
import com.google.cloud.datastore.DatastoreTypeConverter
import com.google.cloud.datastore.Entity
import com.google.cloud.datastore.FullEntity
import com.google.cloud.datastore.IncompleteKey
import com.google.cloud.datastore.Key
import com.google.cloud.datastore.KeyFactory
import com.google.cloud.datastore.Query
import com.google.cloud.datastore.QueryResults
import com.google.cloud.datastore.ReadOption
import com.google.cloud.datastore.StructuredQuery
import com.google.cloud.datastore.Transaction
import com.google.datastore.v1.Key.PathElement.IdTypeCase
import com.google.datastore.v1.PropertyFilter
import com.google.datastore.v1.TransactionOptions
import com.google.datastore.v1.Value
import com.google.protobuf.ByteString
import com.google.protobuf.NullValue
import com.google.protobuf.Timestamp
import org.khanacademy.datastore.DatastoreBackend
import org.khanacademy.datastore.DatastoreEnv
import org.khanacademy.datastore.DatastoreEnvWithProject
import org.khanacademy.datastore.DatastoreKey
import org.khanacademy.datastore.restoreLocalDBAfter
import org.khanacademy.datastore.toDatastoreEntity
import org.khanacademy.metadata.Keyed

typealias KeyPb = com.google.datastore.v1.Key

/**
 * An implementation of Google's `Datastore` that throws on all methods.
 *
 * We use this as the default to make sure that tests always have to choose
 * their behavior explicitly.
 *
 * TODO(colin): I autogenerated these stubs from a java interface, and it's not
 * clear that the nullability is right in all cases. Audit this as we fill in
 * the mocked datastore implementation.
 */
open class ThrowingDatastore : Datastore {
    override fun <T : Any?> run(
        query: Query<T>?, vararg options: ReadOption?
    ): QueryResults<T> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> run(query: Query<T>?): QueryResults<T> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun put(entity: FullEntity<*>?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun put(vararg entities: FullEntity<*>?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newKeyFactory(): KeyFactory {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun allocateId(key: IncompleteKey?): Key {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun allocateId(vararg keys: IncompleteKey?): MutableList<Key> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun update(vararg entities: Entity?) {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun add(entity: FullEntity<*>?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun add(vararg entities: FullEntity<*>?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun fetch(
        keys: MutableIterable<Key>?, vararg options: ReadOption?
    ): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun fetch(vararg keys: Key?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> runInTransaction(
        callable: Datastore.TransactionCallable<T>?
    ): T {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> runInTransaction(
        callable: Datastore.TransactionCallable<T>?,
        options: TransactionOptions?
    ): T {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newBatch(): Batch {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newTransaction(options: TransactionOptions?): Transaction {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newTransaction(): Transaction {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(key: Key?, vararg options: ReadOption?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(
        keys: MutableIterable<Key>?, vararg options: ReadOption?
    ): MutableIterator<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(key: Key?): Entity? {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(vararg keys: Key?): MutableIterator<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun getOptions(): DatastoreOptions {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun delete(vararg keys: Key?) {
        throw NotImplementedError("You must mock the datastore in tests.")
    }
}

class DatastoreTestStub : DatastoreBackend {
    override val envs: List<DatastoreEnv> = listOf(DatastoreEnv.TEST)

    override fun getDatastore(
        envAndProject: DatastoreEnvWithProject
    ): Datastore = ThrowingDatastore()
}

/**
 * Implementation of java.lang.Comparable for Timestamps.
 */
internal fun Timestamp.compareTo(other: Timestamp): Int {
    val resultToSeconds = this.seconds.compareTo(other.seconds)
    return if (resultToSeconds == 0) {
        this.nanos.compareTo(other.nanos)
    } else {
        resultToSeconds
    }
}

/**
 * If a list is shorter than a specified size, pad it with nulls to that size.
 */
internal fun <T> maybeNullPad(list: List<T>, toLength: Int): List<T?> =
    if (list.size >= toLength) {
        list
    } else {
        list + List(toLength - list.size) { null }
    }

/**
 * Implementation of java.lang.Comparable for Key protobufs.
 *
 * For keys of the same number of path elements and the same type, this
 * compares as would (kind, id, kind, id, ...) tuples.
 *
 * If we're comparing a key to another key that's longer but shares the same
 * prefix, the shorter key is ordered first.
 *
 * If we're comparing keys of mixed name / id types, an integer ID always
 * compares lower than a string name.
 *
 * These edge-case comparison rules are based on the key comparison code in
 * the python datastore API:
 * https://github.com/Khan/frankenserver/blob/master/python/google/appengine/api/datastore_types.py
 *
 * TODO(colin): if we relax the single-project constraint, then we should
 * compare projectId (called app in python) here too.
 */
internal fun KeyPb.compareTo(other: KeyPb): Int {
    if (partitionId.namespaceId != other.partitionId.namespaceId) {
        return partitionId.namespaceId.compareTo(other.partitionId.namespaceId)
    }

    val elementPairs = maybeNullPad(pathList, other.pathList.size)
        .zip(maybeNullPad(other.pathList, pathList.size))

    return elementPairs.fold(0) { result, (left, right) ->
        when {
            // If an earlier element compared non-equal, we use that result.
            result != 0 -> result

            // null compares less than everything
            left == null && right != null -> -1
            left != null && right == null -> 1
            left == null && right == null -> 0

            // Compare kinds first according to normal string rules.
            // We're using null assertions here because the compiler can't
            // infer the above three boolean conditions were an exhaustive null
            // check.
            left!!.kind != right!!.kind ->
                left.kind.compareTo(right.kind)

            // IDs always compare less than names.
            left.idTypeCase == IdTypeCase.ID &&
                right.idTypeCase == IdTypeCase.NAME -> -1
            left.idTypeCase == IdTypeCase.NAME &&
                right.idTypeCase == IdTypeCase.ID -> 1

            // If we have the same ID/name type for both, use normal comparison
            // rules.
            left.idTypeCase == IdTypeCase.ID ->
                left.id.compareTo(right.id)
            left.idTypeCase == IdTypeCase.NAME ->
                left.name.compareTo(right.name)
            else ->
                throw Exception(
                    "This should be unreachable code and reflects a bug in " +
                        "the library. Debug: left = $left, right = $right.")
        }
    }
}

// Used to order values of different types, as per
// https://cloud.google.com/datastore/docs/concepts/entities#value_type_ordering
private fun Value.typeIndex(): Int =
    when (valueTypeCase) {
        Value.ValueTypeCase.NULL_VALUE -> 1
        Value.ValueTypeCase.INTEGER_VALUE,
        Value.ValueTypeCase.TIMESTAMP_VALUE -> 2
        Value.ValueTypeCase.BOOLEAN_VALUE -> 3
        // The docs say "byte strings" sort before "unicode strings".
        // I'm taking the first to mean "blob" and the second "string".
        Value.ValueTypeCase.BLOB_VALUE -> 4
        Value.ValueTypeCase.STRING_VALUE -> 5
        Value.ValueTypeCase.DOUBLE_VALUE -> 6
        Value.ValueTypeCase.GEO_POINT_VALUE -> 7
        Value.ValueTypeCase.KEY_VALUE -> 8
        Value.ValueTypeCase.ENTITY_VALUE,
        Value.ValueTypeCase.ARRAY_VALUE ->
            throw IllegalArgumentException(
                "Callers should be comparing list/entity values explicitly.")
        Value.ValueTypeCase.VALUETYPE_NOT_SET, null ->
            throw IllegalArgumentException(
                "Cannot query on values of unknown type.")
    }

/**
 * Implementation of java.lang.Comparable for Values, used in query conditions.
 *
 * We assume that both values are of the same type.
 */
internal operator fun Value.compareTo(other: Value): Int {
    // First, handle the case the values are of different types.
    val indexCmp = typeIndex().compareTo(other.typeIndex())
    if (indexCmp != 0) {
        return indexCmp
    }
    return when (valueTypeCase) {
        // Now, handle the (common) case the values are of the same type.
        Value.ValueTypeCase.NULL_VALUE -> 0
        Value.ValueTypeCase.BOOLEAN_VALUE ->
            this.booleanValue.compareTo(other.booleanValue)
        Value.ValueTypeCase.INTEGER_VALUE ->
            this.integerValue.compareTo(other.integerValue)
        Value.ValueTypeCase.DOUBLE_VALUE ->
            this.doubleValue.compareTo(other.doubleValue)
        Value.ValueTypeCase.TIMESTAMP_VALUE ->
            this.timestampValue.compareTo(other.timestampValue)
        Value.ValueTypeCase.KEY_VALUE ->
            this.keyValue.compareTo(other.keyValue)
        Value.ValueTypeCase.STRING_VALUE ->
            this.stringValue.compareTo(other.stringValue)
        Value.ValueTypeCase.BLOB_VALUE ->
            throw IllegalArgumentException("Cannot query on blob values.")
        Value.ValueTypeCase.GEO_POINT_VALUE ->
            TODO("Implement geo point properties")
        Value.ValueTypeCase.ENTITY_VALUE ->
            TODO("Implement entity properties")
        Value.ValueTypeCase.ARRAY_VALUE ->
            TODO("Implement repeated properties")
        Value.ValueTypeCase.VALUETYPE_NOT_SET, null ->
            throw IllegalArgumentException(
                "Cannot query on values of unknown type (value $this).")
        else ->
            throw IllegalArgumentException(
                "Unhandled value type case $valueTypeCase.")
    }
}

internal data class ComparableValue(
    val value: Value
) : Comparable<ComparableValue> {
    override operator fun compareTo(other: ComparableValue): Int =
        this.value.compareTo(other.value)
}

/**
 * Return a list of the ancestors (prefixes) of this key, including itself.
 *
 * For example, Key("A", 1, "B", 2, "C", 3).ancestors(), would return
 * Key("A", 1, "B", 2, "C", 3), Key("A", 1, "B", 2), Key("A", 1).
 */
private fun Key.ancestors(): List<Key> {
    var key: Key? = this
    val ancestors = mutableListOf<Key>()
    while (key != null) {
        ancestors.add(key)
        key = key.parent
    }
    return ancestors
}

private fun Value.isArray(): Boolean =
    valueTypeCase == Value.ValueTypeCase.ARRAY_VALUE

/**
 * Does the provided entity match the given filter?
 *
 * We treat missing values on the entity as `null`.
 */
internal fun entityMatches(
    entityKey: Key,
    entityValue: Value,
    filter: PropertyFilter
): Boolean {
    val filterValue = filter.value

    // matchesFilters(), the caller of entityMatches(), should have
    // already filtered out the array case.
    assert(!entityValue.isArray())

    // TODO(colin): should we complain if
    //    filter.value.valueTypeCase != entityValue.valueTypeCase
    // and neither is null?  This is probably a programming error.

    return when (filter.op) {
        PropertyFilter.Operator.EQUAL ->
            // Note that we're not using the == operator because the ordering
            // we're using here is not guaranteed to match the behavior of
            // equals. (In particular some types may use object identity, which
            // we don't want.)
            entityValue.compareTo(filterValue) == 0
        PropertyFilter.Operator.GREATER_THAN ->
            entityValue > filterValue
        PropertyFilter.Operator.GREATER_THAN_OR_EQUAL ->
            entityValue >= filterValue
        PropertyFilter.Operator.LESS_THAN ->
            entityValue < filterValue
        PropertyFilter.Operator.LESS_THAN_OR_EQUAL ->
            entityValue <= filterValue
        PropertyFilter.Operator.HAS_ANCESTOR ->
            // TODO(benkraft): The caller does a bit of extra -- and
            // semantically questionable -- work in this case, namely
            // extracting out entityValue despite knowing it won't exist (since
            // the name is the magic __key__) and we won't need it (we want to
            // look at entity.key).  But none of it errors (we just get the
            // null value), so we don't worry about it!
            entityKey.ancestors().contains(
                DatastoreTypeConverter.keyFromPb(filterValue.keyValue))
        PropertyFilter.Operator.OPERATOR_UNSPECIFIED,
        PropertyFilter.Operator.UNRECOGNIZED,
        null ->
            throw IllegalArgumentException(
                "Cannot run a query with unspecified operator.")
    }
}

private fun PropertyFilter.isInequalityFilter(): Boolean {
    return when (op) {
        PropertyFilter.Operator.GREATER_THAN,
        PropertyFilter.Operator.GREATER_THAN_OR_EQUAL,
        PropertyFilter.Operator.LESS_THAN,
        PropertyFilter.Operator.LESS_THAN_OR_EQUAL -> true
        else -> false
    }
}

/**
 * Mock transaction class, simulating some of the behavior of the datsatore.
 *
 * Note that in contrast to NDB, we have no context cache, so this implements
 * the datastore-native behavior that if you do a get, put, get sequence on the
 * same entity in the same transaction, you do not see the result of the put in
 * the second get.
 *
 * TODO(colin): at present this will throw on queries. We should allow ancestor
 * queries.
 *
 * TODO(colin): this does not currently throw on concurrent modification.
 *
 * TODO(colin): this does not match the prod behavior with respect to
 * concurrent modification of different entities in the same group.
 */
class MockTransaction(
    private val parent: MockDatastore
) : ThrowingDatastore(), Transaction {
    private var innerDatastoreForReads = MockDatastore(listOf())
    private var innerDatastoreForWrites = MockDatastore(listOf())

    // Transaction-specific methods

    // We don't expose the transaction object outside the library, so just use
    // a dummy value.
    override fun isActive(): Boolean = true

    private fun reset() {
        innerDatastoreForReads.entities = listOf()
        innerDatastoreForWrites.entities = listOf()
    }

    override fun rollback() {
        reset()
    }

    override fun getDatastore(): Datastore = parent

    override fun commit(): Transaction.Response {
        parent.put(*innerDatastoreForWrites.entities.toTypedArray())
        reset()
        return Transaction.Response { listOf() }
    }

    override fun getTransactionId(): ByteString {
        throw NotImplementedError("Not supported in the test stub.")
    }

    override fun putWithDeferredIdAllocation(vararg entities: FullEntity<*>?) {
        throw NotImplementedError("Not supported in the test stub.")
    }

    override fun addWithDeferredIdAllocation(vararg entities: FullEntity<*>?) {
        throw NotImplementedError("Not supported in the test stub.")
    }

    // Selected Datastore methods
    override fun get(key: Key?): Entity? {
        val inner = innerDatastoreForReads.get(key)
        if (inner == null) {
            val fromParent = parent.get(key)
            if (fromParent != null) {
                innerDatastoreForReads.put(fromParent)
            }
        }
        return innerDatastoreForReads.get(key)
    }

    override fun get(vararg keys: Key?): MutableIterator<Entity> {
        return keys.mapNotNull { key -> this.get(key) }
            .toMutableList().listIterator()
    }

    override fun put(entity: FullEntity<*>?): Entity =
        innerDatastoreForWrites.put(entity)

    override fun put(vararg entities: FullEntity<*>?): MutableList<Entity> =
        innerDatastoreForWrites.put(*entities)
}

/**
 * Datastore implementation that uses a list of entities as its fake contents.
 *
 * TODO(colin): this doesn't support the full set of datastore operations yet.
 * Fill this in as more functionality is implemented. For now this will throw
 * on any unimplemented operations.
 *
 * TODO(colin): we'll want to do some synchronization around updating the
 * internal state.
 */
class MockDatastore(
    internal var entities: List<Entity>
) : ThrowingDatastore() {
    override fun get(key: Key?): Entity? =
        entities.firstOrNull { it.key == key }

    override fun get(vararg keys: Key?): MutableIterator<Entity> {
        return keys.mapNotNull { key -> this.get(key) }
            .toMutableList().listIterator()
    }

    override fun put(entity: FullEntity<*>?): Entity {
        val entityConverted = entity as Entity
        entities = entities.filter { it.key != entity.key } + entityConverted
        return entityConverted
    }

    override fun put(vararg entities: FullEntity<*>?): MutableList<Entity> {
        val entitiesConverted = entities.map { it as Entity }
        val keys = entitiesConverted.map { it.key }
        this.entities = this.entities.filter { it.key !in keys } +
            entitiesConverted
        return entitiesConverted.toMutableList()
    }

    // Checks that we match all filters that have the same name and
    // is-inequality status.  For instance, filters might be
    // `(myint > 4, myint < 6)` -- but would never be
    // `(myint > 4, myint = 5)`.
    private fun matchesFiltersForField(
        entity: Entity,
        filters: List<PropertyFilter>
    ): Boolean {
        val filterName = filters[0].property.name
        val entityValue = DatastoreTypeConverter.entityToPb(entity)
            .propertiesMap[filterName]
            ?: Value.newBuilder().setNullValue(NullValue.NULL_VALUE).build()

        // If we have an array-value and inequality filters, we have
        // to use this rule: the entity passes if there is some value
        // in the array which passes all the inequalities.  For
        // instance if we have '(myint > 4, myint < 6)', and our array
        // values are [3, 10], we do *not* pass because neither array
        // value passes both inequalities.
        // Note if filters[0] is an inequality filter, they all are,
        // because of how we grouped the filters.
        return when {
            entityValue.isArray() && filters[0].isInequalityFilter() ->
                entityValue.arrayValue.valuesList.any { value ->
                    filters.all {
                        filter -> entityMatches(entity.key, value, filter)
                    }
                }

            entityValue.isArray() ->
                // This is equality for arrays, we do the "normal"
                // thing where we match filter-by-filter: each equality
                // filter passes if the filter-string is present in our array.
                filters.all { filter ->
                    entityValue.arrayValue.valuesList.any { value ->
                        entityMatches(entity.key, value, filter)
                    }
                }

            else ->
                // Non-array case, very straightforward.
                filters.all {
                    filter -> entityMatches(entity.key, entityValue, filter)
                }
        }
    }

    /**
     * Get a comparable value to use in an array-valued-property ordering.
     *
     * Array-valued properties compare in surprising ways! See
     * https://cloud.google.com/datastore/docs/concepts/queries#properties_with_array_values_can_behave_in_surprising_ways
     *
     * To summarize, if there's no filter on the property by which we're
     * ordering, we use the min value for ascending order, or the max value for
     * descending. If there is an inequality filter on this property, we do the
     * same, but only looking at values that pass the filter. If there is an
     * equality filter on this property, we ignore any sort order.
     *
     * Note that if the array value is empty, it is effectively filtered out of
     * any ordered results (even if there is no filter on that property)!
     * Callers should already have done this filtering.
     */
    private fun arrayValuedComparable(
        condition: StructuredQuery.OrderBy,
        filters: List<PropertyFilter>,
        propertyValue: Value
    ): ComparableValue {
        val filtersForProperty = filters.filter {
            it.property.name == condition.property
        }
        return when {
            filtersForProperty.isEmpty() ->
                if (condition.direction ==
                    StructuredQuery.OrderBy.Direction.ASCENDING) {
                    ComparableValue(
                        propertyValue.arrayValue.valuesList.minBy {
                            ComparableValue(it)
                        } ?: throw IllegalStateException(
                            "Callers must filter out empty-array values.")
                    )
                } else {
                    ComparableValue(
                        propertyValue.arrayValue.valuesList.maxBy {
                            ComparableValue(it)
                        } ?: throw IllegalStateException(
                            "Callers must filter out empty-array values.")
                    )
                }
            filtersForProperty.all { it.isInequalityFilter() } -> {
                val valuesToExamine = propertyValue.arrayValue.valuesList
                    .filter { value ->
                        filtersForProperty.all { propertyFilter ->
                            entityMatches(
                                // Use a dummy key, as that only applies to
                                // ancestor filters, which we won't be
                                // considering here.
                                Key.newBuilder("project", "kind", "id")
                                    .build(),
                                value,
                                propertyFilter)
                        }
                    }
                if (condition.direction ==
                    StructuredQuery.OrderBy.Direction.ASCENDING) {
                    ComparableValue(
                        valuesToExamine.minBy {
                            ComparableValue(it)
                        } ?: throw IllegalStateException(
                            "Callers must filter out empty-array values.")
                    )
                } else {
                    ComparableValue(
                        valuesToExamine.maxBy {
                            ComparableValue(it)
                        } ?: throw IllegalStateException(
                            "Callers must filter out empty-array values.")
                    )
                }
            }
            else ->
                // We ignore sort order for any equality filters, which we do
                // by just returning a constant value for all entities.
                ComparableValue(Value.newBuilder().setIntegerValue(0).build())
        }
    }

    private fun queryComparator(
        condition: StructuredQuery.OrderBy,
        filters: List<PropertyFilter>
    ): Comparator<Entity> {
        val comparator = compareBy<Entity> { entity ->
            val propertyValue = DatastoreTypeConverter.valueToPb(
                entity.getValue(condition.property))
            if (propertyValue.isArray()) {
                arrayValuedComparable(condition, filters, propertyValue)
            } else {
                ComparableValue(propertyValue)
            }
        }
        return when (condition.direction) {
            StructuredQuery.OrderBy.Direction.ASCENDING ->
                comparator
            StructuredQuery.OrderBy.Direction.DESCENDING ->
                comparator.reversed()
            else ->
                throw IllegalArgumentException(
                    "Query order must either be ascending or descending")
        }
    }

    private fun runEntities(query: Query<*>?): List<Entity> {
        val structuredQuery = query as? StructuredQuery<*>
            ?: throw NotImplementedError(
                "Only structured queries are implemented in the test stub.")
        val filter = DatastoreTypeConverter.filterToPb(structuredQuery.filter)
        // TODO(colin): this only handles a top-level composite filter, which
        // is all our query code will currently generate. But probably better
        // to enforce this somehow?
        val allFilters = if (filter.hasCompositeFilter()) {
            filter.compositeFilter.filtersList.map { it.propertyFilter }
        } else {
            listOf(filter.propertyFilter)
        }

        // Most of the time, an entity passes a list of filters if it
        // passes each filter individually.  However, there is a
        // special case, as documented at
        // https://cloud.google.com/datastore/docs/concepts/queries#array_values
        // This case is inequality filters on array values.  For those
        // filters, we need to consider the filters *as a group*, not
        // just one at a time.  To help with that, we group filters
        // by <name, is_inequality_filter>.
        val filtersByNameAndType = allFilters.groupBy {
            Pair(it.property.name, it.isInequalityFilter())
        }

        val filteredResult = entities
            .filter { entity -> entity.key.kind == query.kind }
            .filter { entity ->
                // We consider each filter-group in sequence, the
                // entity has to pass them all.
                filtersByNameAndType.all { entry ->
                    matchesFiltersForField(entity, entry.value)
                }
            }
        return if (structuredQuery.orderBy.isEmpty()) {
            filteredResult
        } else {
            val initial = queryComparator(
                structuredQuery.orderBy.first(), allFilters)
            val comparator = structuredQuery.orderBy
                .drop(1)
                .fold(initial) { comp, condition ->
                    comp.then(queryComparator(condition, allFilters))
                }
            // If we happen to be ordering on a repeated property, then this has
            // the additional effect of filtering out empty-array values!
            filteredResult.filterNot { entity ->
                structuredQuery.orderBy.any { order ->
                    val value = DatastoreTypeConverter.valueToPb(
                        entity.getValue(order.property))
                    value.isArray() && value.arrayValue.valuesList.isEmpty()
                }
            }.sortedWith(comparator)
        }
    }

    private fun runKeys(query: Query<*>?): List<DatastoreKey> =
        runEntities(query).map { it.key }

    @Suppress("UNCHECKED_CAST")
    override fun <T> run(query: Query<T>?): QueryResults<T> {
        val resultType = DatastoreTypeConverter.queryResultType(query)
        return when (resultType) {
            Query.ResultType.ENTITY ->
                MockQueryResults(runEntities(query))
            Query.ResultType.KEY ->
                MockQueryResults(runKeys(query))
            else ->
                throw NotImplementedError(
                    "Only entity and key queries are supported.")
        } as QueryResults<T>
    }

    override fun newTransaction(): Transaction = MockTransaction(this)

    companion object {
        class MockQueryResults<T>(
            private val results: List<T>
        ) : QueryResults<T>, Iterator<T> by results.iterator() {
            override fun getSkippedResults(): Int {
                throw NotImplementedError("Not implemented in the test stub.")
            }

            override fun getCursorAfter(): Cursor {
                throw NotImplementedError("Not implemented in the test stub.")
            }

            override fun remove() {
                throw NotImplementedError("Not implemented in the test stub.")
            }

            override fun getResultClass(): Class<*> {
                throw NotImplementedError("Not implemented in the test stub.")
            }
        }
    }
}

/**
 * Within a block of code, mock the datastore to contain the provided objects.
 */
fun <T> withMockDatastore(
    vararg entities: Keyed<*>, block: () -> T
): T {
    val converted = entities.map { it.toDatastoreEntity() }.toTypedArray()
    return withMockDatastore(*converted, block = block)
}

/**
 * Within a block of code, mock the datastore to contain the provided objects.
 */
fun <T> withMockDatastore(
    entities: Collection<Keyed<*>>, block: () -> T
) = withMockDatastore(*entities.toTypedArray(), block = block)

/**
 * Within a block of code, mock the datastore to contain the provided entities.
 *
 * Note that this is intended primarily for testing in contexts where
 * third-party APIs use `Entity`s. Prefer to use the version with Keyed<*>
 * instead where possible.
 */
fun <T> withMockDatastore(
    vararg entities: Entity, block: () -> T
): T = restoreLocalDBAfter {
    // NOTE: this constructor will set the value of `localDB`
    org.khanacademy.datastore.Datastore(MockDatastore(entities.toList()))
    block()
}
