/**
 * Utilities for stubbing out the datastore in library clients' tests.
 *
 * We provide a lightweight test stub that can do basic operations on a list of
 * entities that you provide as the fake datastore contents. This is very
 * lightweight, and suitable for tests that touch code that needs to do some
 * simple datastore operations, but we don't simulate all behavior of the
 * datastore, like eventual consistency, transaction collisions, etc.
 *
 * TODO(colin): the Google client library suggests using the datastore emulator
 * for testing. We should support that as an alternate heavier-weight but more
 * accurate implementation for the test stub.
 *
 * To use:
 * - include org.khanacademy.datastore.testutil.DatastoreTestStub using the
 *   service loader pattern. This will cause all datastore access to throw by
 *   default.
 * - Provide mock datastore behavior within whatever scope is appropriate for
 *   your tests using `withMockDatastore`, which takes a variable number of
 *   either Keyed<*> or Entity, representing the entities that should be in the
 *   mock datastore.
 *
 * Example usage (Entity-based interface):
 *
 * val myKey: Key<TestModel> = ...
 * val myEntity = Entity.newBuilder(myKey.toDatastoreKey())
 *     .setString("aString", "a_string_value")
 *     .build()
 *
 * withMockDatastore(myEntity) {
 *     DB.get(myKey).aString shouldBe "a_string_value"
 * }
 */
package org.khanacademy.datastore.testutil

import com.google.cloud.datastore.Batch
import com.google.cloud.datastore.Datastore
import com.google.cloud.datastore.DatastoreOptions
import com.google.cloud.datastore.Entity
import com.google.cloud.datastore.FullEntity
import com.google.cloud.datastore.IncompleteKey
import com.google.cloud.datastore.Key
import com.google.cloud.datastore.KeyFactory
import com.google.cloud.datastore.Query
import com.google.cloud.datastore.QueryResults
import com.google.cloud.datastore.ReadOption
import com.google.cloud.datastore.Transaction
import com.google.datastore.v1.TransactionOptions
import org.khanacademy.datastore.DatastoreBackend
import org.khanacademy.datastore.DatastoreEnv
import org.khanacademy.datastore.DatastoreEnvWithProject
import org.khanacademy.datastore.restoreLocalDBAfter
import org.khanacademy.datastore.toDatastoreEntity
import org.khanacademy.metadata.Keyed

/**
 * An implementation of Google's `Datastore` that throws on all methods.
 *
 * We use this as the default to make sure that tests always have to choose
 * their behavior explicitly.
 *
 * TODO(colin): I autogenerated these stubs from a java interface, and it's not
 * clear that the nullability is right in all cases. Audit this as we fill in
 * the mocked datastore implementation.
 */
open class ThrowingDatastore : Datastore {
    override fun <T : Any?> run(
        query: Query<T>?, vararg options: ReadOption?
    ): QueryResults<T> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> run(query: Query<T>?): QueryResults<T> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun put(entity: FullEntity<*>?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun put(vararg entities: FullEntity<*>?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newKeyFactory(): KeyFactory {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun allocateId(key: IncompleteKey?): Key {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun allocateId(vararg keys: IncompleteKey?): MutableList<Key> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun update(vararg entities: Entity?) {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun add(entity: FullEntity<*>?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun add(vararg entities: FullEntity<*>?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun fetch(
        keys: MutableIterable<Key>?, vararg options: ReadOption?
    ): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun fetch(vararg keys: Key?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> runInTransaction(
        callable: Datastore.TransactionCallable<T>?
    ): T {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> runInTransaction(
        callable: Datastore.TransactionCallable<T>?,
        options: TransactionOptions?
    ): T {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newBatch(): Batch {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newTransaction(options: TransactionOptions?): Transaction {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newTransaction(): Transaction {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(key: Key?, vararg options: ReadOption?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(
        keys: MutableIterable<Key>?, vararg options: ReadOption?
    ): MutableIterator<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(key: Key?): Entity? {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(vararg keys: Key?): MutableIterator<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun getOptions(): DatastoreOptions {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun delete(vararg keys: Key?) {
        throw NotImplementedError("You must mock the datastore in tests.")
    }
}

class DatastoreTestStub : DatastoreBackend {
    override val envs: List<DatastoreEnv> = listOf(DatastoreEnv.TEST)

    override fun getDatastore(
        envAndProject: DatastoreEnvWithProject
    ): Datastore = ThrowingDatastore()
}

/**
 * Datastore implementation that uses a list of entities as its fake contents.
 *
 * TODO(colin): this doesn't support the full set of datastore operations yet.
 * Fill this in as more functionality is implemented. For now this will throw
 * on any unimplemented operations.
 *
 * TODO(colin): we'll want to do some synchronization around updating the
 * internal state.
 */
class MockDatastore(private var entities: List<Entity>) : ThrowingDatastore() {
    override fun get(key: Key?): Entity? =
        entities.firstOrNull { it.key == key }

    override fun put(entity: FullEntity<*>?): Entity {
        val entityConverted = entity as Entity
        entities += entityConverted
        return entityConverted
    }
}

/**
 * Within a block of code, mock the datastore to contain the provided objects.
 */
fun <T> withMockDatastore(
    vararg entities: Keyed<*>, block: () -> T
): T {
    val converted = entities.map { it.toDatastoreEntity() }.toTypedArray()
    return withMockDatastore(*converted, block = block)
}

/**
 * Within a block of code, mock the datastore to contain the provided entities.
 *
 * Note that this is intended primarily for testing in contexts where
 * third-party APIs use `Entity`s. Prefer to use the version with Keyed<*>
 * instead where possible.
 */
fun <T> withMockDatastore(
    vararg entities: Entity, block: () -> T
): T = restoreLocalDBAfter {
    // NOTE: this constructor will set the value of `localDB`
    org.khanacademy.datastore.Datastore(MockDatastore(entities.toList()))
    block()
}
