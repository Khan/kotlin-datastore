/**
 * Utilities for stubbing out the datastore in library clients' tests.
 *
 * We provide a lightweight test stub that can do basic operations on a list of
 * entities that you provide as the fake datastore contents. This is very
 * lightweight, and suitable for tests that touch code that needs to do some
 * simple datastore operations, but we don't simulate all behavior of the
 * datastore, like eventual consistency, transaction collisions, etc.
 *
 * TODO(colin): the Google client library suggests using the datastore emulator
 * for testing. We should support that as an alternate heavier-weight but more
 * accurate implementation for the test stub.
 *
 * To use:
 * - include org.khanacademy.datastore.testutil.DatastoreTestStub using the
 *   service loader pattern. This will cause all datastore access to throw by
 *   default.
 * - Provide mock datastore behavior within whatever scope is appropriate for
 *   your tests using `withMockDatastore`, which takes a variable number of
 *   either Keyed<*> or Entity, representing the entities that should be in the
 *   mock datastore.
 *
 * Example usage (Entity-based interface):
 *
 * val myKey: Key<TestModel> = ...
 * val myEntity = Entity.newBuilder(myKey.toDatastoreKey())
 *     .setString("aString", "a_string_value")
 *     .build()
 *
 * withMockDatastore(myEntity) {
 *     DB.get(myKey).aString shouldBe "a_string_value"
 * }
 */
package org.khanacademy.datastore.testutil

import com.google.cloud.datastore.Batch
import com.google.cloud.datastore.Cursor
import com.google.cloud.datastore.Datastore
import com.google.cloud.datastore.DatastoreOptions
import com.google.cloud.datastore.DatastoreTypeConverter
import com.google.cloud.datastore.Entity
import com.google.cloud.datastore.FullEntity
import com.google.cloud.datastore.IncompleteKey
import com.google.cloud.datastore.Key
import com.google.cloud.datastore.KeyFactory
import com.google.cloud.datastore.Query
import com.google.cloud.datastore.QueryResults
import com.google.cloud.datastore.ReadOption
import com.google.cloud.datastore.StructuredQuery
import com.google.cloud.datastore.Transaction
import com.google.datastore.v1.Key.PathElement.IdTypeCase
import com.google.datastore.v1.PropertyFilter
import com.google.datastore.v1.TransactionOptions
import com.google.datastore.v1.Value
import com.google.protobuf.NullValue
import com.google.protobuf.Timestamp
import org.khanacademy.datastore.DatastoreBackend
import org.khanacademy.datastore.DatastoreEnv
import org.khanacademy.datastore.DatastoreEnvWithProject
import org.khanacademy.datastore.DatastoreKey
import org.khanacademy.datastore.restoreLocalDBAfter
import org.khanacademy.datastore.toDatastoreEntity
import org.khanacademy.metadata.Keyed

typealias KeyPb = com.google.datastore.v1.Key

/**
 * An implementation of Google's `Datastore` that throws on all methods.
 *
 * We use this as the default to make sure that tests always have to choose
 * their behavior explicitly.
 *
 * TODO(colin): I autogenerated these stubs from a java interface, and it's not
 * clear that the nullability is right in all cases. Audit this as we fill in
 * the mocked datastore implementation.
 */
open class ThrowingDatastore : Datastore {
    override fun <T : Any?> run(
        query: Query<T>?, vararg options: ReadOption?
    ): QueryResults<T> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> run(query: Query<T>?): QueryResults<T> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun put(entity: FullEntity<*>?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun put(vararg entities: FullEntity<*>?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newKeyFactory(): KeyFactory {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun allocateId(key: IncompleteKey?): Key {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun allocateId(vararg keys: IncompleteKey?): MutableList<Key> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun update(vararg entities: Entity?) {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun add(entity: FullEntity<*>?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun add(vararg entities: FullEntity<*>?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun fetch(
        keys: MutableIterable<Key>?, vararg options: ReadOption?
    ): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun fetch(vararg keys: Key?): MutableList<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> runInTransaction(
        callable: Datastore.TransactionCallable<T>?
    ): T {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun <T : Any?> runInTransaction(
        callable: Datastore.TransactionCallable<T>?,
        options: TransactionOptions?
    ): T {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newBatch(): Batch {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newTransaction(options: TransactionOptions?): Transaction {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun newTransaction(): Transaction {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(key: Key?, vararg options: ReadOption?): Entity {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(
        keys: MutableIterable<Key>?, vararg options: ReadOption?
    ): MutableIterator<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(key: Key?): Entity? {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun get(vararg keys: Key?): MutableIterator<Entity> {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun getOptions(): DatastoreOptions {
        throw NotImplementedError("You must mock the datastore in tests.")
    }

    override fun delete(vararg keys: Key?) {
        throw NotImplementedError("You must mock the datastore in tests.")
    }
}

class DatastoreTestStub : DatastoreBackend {
    override val envs: List<DatastoreEnv> = listOf(DatastoreEnv.TEST)

    override fun getDatastore(
        envAndProject: DatastoreEnvWithProject
    ): Datastore = ThrowingDatastore()
}

/**
 * Implementation of java.lang.Comparable for Timestamps.
 */
internal fun Timestamp.compareTo(other: Timestamp): Int {
    val resultToSeconds = this.seconds.compareTo(other.seconds)
    return if (resultToSeconds == 0) {
        this.nanos.compareTo(other.nanos)
    } else {
        resultToSeconds
    }
}

/**
 * If a list is shorter than a specified size, pad it with nulls to that size.
 */
internal fun <T> maybeNullPad(list: List<T>, toLength: Int): List<T?> =
    if (list.size >= toLength) {
        list
    } else {
        list + List(toLength - list.size) { null }
    }

/**
 * Implementation of java.lang.Comparable for Key protobufs.
 *
 * For keys of the same number of path elements and the same type, this
 * compares as would (kind, id, kind, id, ...) tuples.
 *
 * If we're comparing a key to another key that's longer but shares the same
 * prefix, the shorter key is ordered first.
 *
 * If we're comparing keys of mixed name / id types, an integer ID always
 * compares lower than a string name.
 *
 * These edge-case comparison rules are based on the key comparison code in
 * the python datastore API:
 * https://github.com/Khan/frankenserver/blob/master/python/google/appengine/api/datastore_types.py
 *
 * TODO(colin): if we relax the single-project constraint, then we should
 * compare projectId (called app in python) here too.
 */
internal fun KeyPb.compareTo(other: KeyPb): Int {
    if (partitionId.namespaceId != other.partitionId.namespaceId) {
        return partitionId.namespaceId.compareTo(other.partitionId.namespaceId)
    }

    val elementPairs = maybeNullPad(pathList, other.pathList.size)
        .zip(maybeNullPad(other.pathList, pathList.size))

    return elementPairs.fold(0) { result, (left, right) ->
        when {
            // If an earlier element compared non-equal, we use that result.
            result != 0 -> result

            // null compares less than everything
            left == null && right != null -> -1
            left != null && right == null -> 1
            left == null && right == null -> 0

            // Compare kinds first according to normal string rules.
            // We're using null assertions here because the compiler can't
            // infer the above three boolean conditions were an exhaustive null
            // check.
            left!!.kind != right!!.kind ->
                left.kind.compareTo(right.kind)

            // IDs always compare less than names.
            left.idTypeCase == IdTypeCase.ID &&
                right.idTypeCase == IdTypeCase.NAME -> -1
            left.idTypeCase == IdTypeCase.NAME &&
                right.idTypeCase == IdTypeCase.ID -> 1

            // If we have the same ID/name type for both, use normal comparison
            // rules.
            left.idTypeCase == IdTypeCase.ID ->
                left.id.compareTo(right.id)
            left.idTypeCase == IdTypeCase.NAME ->
                left.name.compareTo(right.name)
            else ->
                throw Exception(
                    "This should be unreachable code and reflects a bug in " +
                        "the library. Debug: left = $left, right = $right.")
        }
    }
}

/**
 * Implementation of java.lang.Comparable for Values, used in query conditions.
 *
 * We assume that both values are of the same type.
 */
internal operator fun Value.compareTo(other: Value): Int {
    return when (valueTypeCase) {
        Value.ValueTypeCase.NULL_VALUE -> 0
        Value.ValueTypeCase.BOOLEAN_VALUE ->
            this.booleanValue.compareTo(other.booleanValue)
        Value.ValueTypeCase.INTEGER_VALUE ->
            this.integerValue.compareTo(other.integerValue)
        Value.ValueTypeCase.DOUBLE_VALUE ->
            this.doubleValue.compareTo(other.doubleValue)
        Value.ValueTypeCase.TIMESTAMP_VALUE ->
            this.timestampValue.compareTo(other.timestampValue)
        Value.ValueTypeCase.KEY_VALUE ->
            this.keyValue.compareTo(other.keyValue)
        Value.ValueTypeCase.STRING_VALUE ->
            this.stringValue.compareTo(other.stringValue)
        Value.ValueTypeCase.BLOB_VALUE ->
            throw IllegalArgumentException(
                "Cannot query on blob values.")
        Value.ValueTypeCase.GEO_POINT_VALUE ->
            TODO("Implement geo point properties")
        Value.ValueTypeCase.ENTITY_VALUE ->
            TODO("Implement entity properties")
        Value.ValueTypeCase.ARRAY_VALUE ->
            TODO("Implement repeated properties")
        Value.ValueTypeCase.VALUETYPE_NOT_SET, null ->
            throw IllegalArgumentException(
                "Cannot query on values of unknown type.")
    }
}

/**
 * Does the provided entity match the given filter?
 *
 * We treat missing values on the entity as `null`.
 */
internal fun entityMatches(entity: Entity, filter: PropertyFilter): Boolean {
    val name = filter.property.name
    val filterValue = filter.value
    val entityValue = DatastoreTypeConverter.entityToPb(entity)
        .propertiesMap[name]
        ?: Value.newBuilder().setNullValue(NullValue.NULL_VALUE).build()

    // TODO(colin): when implementing repeated values, we'll need to take that
    // into account here.

    // TODO(colin): should we throw here? This probably represents a
    // programming error if we hit this condition?
    if (filterValue.valueTypeCase != entityValue.valueTypeCase) {
        return false
    }

    return when (filter.op) {
        PropertyFilter.Operator.EQUAL ->
            // Note that we're not using the == operator because the ordering
            // we're using here is not guaranteed to match the behavior of
            // equals. (In particular some types may use object identity, which
            // we don't want.)
            entityValue.compareTo(filterValue) == 0
        PropertyFilter.Operator.GREATER_THAN ->
            entityValue > filterValue
        PropertyFilter.Operator.GREATER_THAN_OR_EQUAL ->
            entityValue >= filterValue
        PropertyFilter.Operator.LESS_THAN ->
            entityValue < filterValue
        PropertyFilter.Operator.LESS_THAN_OR_EQUAL ->
            entityValue <= filterValue
        PropertyFilter.Operator.HAS_ANCESTOR ->
            TODO("Implement ancestor queries.")
        PropertyFilter.Operator.OPERATOR_UNSPECIFIED,
        PropertyFilter.Operator.UNRECOGNIZED,
        null ->
            throw IllegalArgumentException(
                "Cannot run a query with unspecified operator.")
    }
}

/**
 * Datastore implementation that uses a list of entities as its fake contents.
 *
 * TODO(colin): this doesn't support the full set of datastore operations yet.
 * Fill this in as more functionality is implemented. For now this will throw
 * on any unimplemented operations.
 *
 * TODO(colin): we'll want to do some synchronization around updating the
 * internal state.
 */
class MockDatastore(private var entities: List<Entity>) : ThrowingDatastore() {
    override fun get(key: Key?): Entity? =
        entities.firstOrNull { it.key == key }

    override fun put(entity: FullEntity<*>?): Entity {
        val entityConverted = entity as Entity
        entities += entityConverted
        return entityConverted
    }

    private fun runEntities(query: Query<*>?): List<Entity> {
        val structuredQuery = query as? StructuredQuery<*>
            ?: throw NotImplementedError(
                "Only structured queries are implemented in the test stub.")
        val filter = DatastoreTypeConverter.filterToPb(structuredQuery.filter)
        // TODO(colin): this only handles a top-level composite filter, which
        // is all our query code will currently generate. But probably better
        // to enforce this somehow?
        val allFilters = if (filter.hasCompositeFilter()) {
            filter.compositeFilter.filtersList.map { it.propertyFilter }
        } else {
            listOf(filter.propertyFilter)
        }

        return entities.filter { entity ->
            allFilters.all { filter ->
                entityMatches(entity, filter)
            }
        }
    }

    private fun runKeys(query: Query<*>?): List<DatastoreKey> =
        runEntities(query).map { it.key }

    @Suppress("UNCHECKED_CAST")
    override fun <T> run(query: Query<T>?): QueryResults<T> {
        val resultType = DatastoreTypeConverter.queryResultType(query)
        return when (resultType) {
            Query.ResultType.ENTITY ->
                MockQueryResults(runEntities(query))
            Query.ResultType.KEY ->
                MockQueryResults(runKeys(query))
            else ->
                throw NotImplementedError(
                    "Only entity and key queries are supported.")
        } as QueryResults<T>
    }

    companion object {
        class MockQueryResults<T>(
            private val results: List<T>
        ) : QueryResults<T>, Iterator<T> by results.iterator() {
            override fun getSkippedResults(): Int {
                throw NotImplementedError("Not implemented in the test stub.")
            }

            override fun getCursorAfter(): Cursor {
                throw NotImplementedError("Not implemented in the test stub.")
            }

            override fun remove() {
                throw NotImplementedError("Not implemented in the test stub.")
            }

            override fun getResultClass(): Class<*> {
                throw NotImplementedError("Not implemented in the test stub.")
            }
        }
    }
}

/**
 * Within a block of code, mock the datastore to contain the provided objects.
 */
fun <T> withMockDatastore(
    vararg entities: Keyed<*>, block: () -> T
): T {
    val converted = entities.map { it.toDatastoreEntity() }.toTypedArray()
    return withMockDatastore(*converted, block = block)
}

/**
 * Within a block of code, mock the datastore to contain the provided objects.
 */
fun <T> withMockDatastore(
    entities: Collection<Keyed<*>>, block: () -> T
) = withMockDatastore(*entities.toTypedArray(), block = block)

/**
 * Within a block of code, mock the datastore to contain the provided entities.
 *
 * Note that this is intended primarily for testing in contexts where
 * third-party APIs use `Entity`s. Prefer to use the version with Keyed<*>
 * instead where possible.
 */
fun <T> withMockDatastore(
    vararg entities: Entity, block: () -> T
): T = restoreLocalDBAfter {
    // NOTE: this constructor will set the value of `localDB`
    org.khanacademy.datastore.Datastore(MockDatastore(entities.toList()))
    block()
}
